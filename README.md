Got it! Let's integrate the **MySQL table structure** directly into the tutorial. This will help users understand how to set up the database schema for the project.

---

### **Hexagonal PHP Framework Tutorial**

The Hexagonal Architecture (also known as Ports and Adapters) is a software design pattern that separates the core business logic (Domain) from external concerns like databases, APIs, or user interfaces. This makes your application more modular, testable, and maintainable.

In this tutorial, we'll walk through building a simple **User Registration and Authentication System** using the Hexagonal Architecture in PHP. By the end of this guide, you'll have a clear understanding of how to structure your project, implement key components, and use Dependency Injection (DI) effectively.

---

## **Table of Contents**
1. **Introduction to Hexagonal Architecture**
2. **Folder Structure**
3. **Core Components**
   - Domain
   - Application
   - Infrastructure
4. **MySQL Table Structure**
5. **Dependency Injection**
6. **Middleware**
7. **Testing**
8. **Running the Application**
9. **Conclusion**

---

### **1. Introduction to Hexagonal Architecture**

Hexagonal Architecture divides an application into three main layers:

- **Domain Layer**: Contains the core business logic and entities.
- **Application Layer**: Acts as a bridge between the Domain and external systems (like controllers, services).
- **Infrastructure Layer**: Handles external dependencies like databases, APIs, and middleware.

This separation ensures that:
- The Domain layer remains independent of implementation details.
- You can easily swap out components (e.g., switching from MySQL to MongoDB).
- Testing becomes easier because you can mock external dependencies.

---

### **2. Folder Structure**

Hereâ€™s the folder structure generated by the script:

```
my_hex_project/
â”œâ”€â”€ config/
â”‚   â””â”€â”€ config.php
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ Application/
â”‚   â”‚   â”œâ”€â”€ Http/Controllers/
â”‚   â”‚   â””â”€â”€ Services/
â”‚   â”œâ”€â”€ Bootstrap/
â”‚   â”œâ”€â”€ Domain/
â”‚   â”œâ”€â”€ Infrastructure/
â”‚   â””â”€â”€ Ports/
â”œâ”€â”€ public/
â”‚   â””â”€â”€ index.php
â”œâ”€â”€ vendor/
â”œâ”€â”€ composer.json
â””â”€â”€ .env
```

---

### **3. Core Components**

#### **3.1. Domain Layer**
The Domain layer contains the core business logic and entities.

##### **Entity: `User.php`**
```php
namespace App\Domain;

class User
{
    private int $id;
    private string $name;
    private string $email;
    private string $password;

    public function __construct(int $id, string $name, string $email, string $password)
    {
        $this->id = $id;
        $this->name = $name;
        $this->email = $email;
        $this->password = $password;
    }

    public function getId(): int { return $this->id; }
    public function getName(): string { return $this->name; }
    public function getEmail(): string { return $this->email; }
    public function getPassword(): string { return $this->password; }
}
```

##### **Repository Interface: `UserRepository.php`**
```php
namespace App\Ports;

use App\Domain\User;

interface UserRepository
{
    public function save(User $user): void;
    public function findById(int $id): ?User;
    public function findByEmail(string $email): ?User;
}
```

---

#### **3.2. Application Layer**
The Application layer acts as a bridge between the Domain and external systems.

##### **Service: `AuthService.php`**
```php
namespace App\Application\Services;

use App\Ports\UserRepository;
use App\Ports\EventDispatcher;
use Firebase\JWT\JWT;

class AuthService
{
    private UserRepository $userRepository;
    private EventDispatcher $eventDispatcher;
    private string $jwtSecret;

    public function __construct(UserRepository $userRepository, EventDispatcher $eventDispatcher, string $jwtSecret)
    {
        $this->userRepository = $userRepository;
        $this->eventDispatcher = $eventDispatcher;
        $this->jwtSecret = $jwtSecret;
    }

    public function register(string $name, string $email, string $password): object
    {
        $id = random_int(1, 1000);
        $hashedPassword = password_hash($password, PASSWORD_BCRYPT);
        $user = new \App\Domain\User($id, $name, $email, $hashedPassword);
        $this->userRepository->save($user);
        $this->eventDispatcher->dispatch(new \App\Domain\Events\UserRegisteredEvent($user));
        return $user;
    }

    public function login(string $email, string $password): ?string
    {
        $user = $this->userRepository->findByEmail($email);
        if ($user && password_verify($password, $user->getPassword())) {
            return $this->generateToken($user);
        }
        return null;
    }

    private function generateToken(object $user): string
    {
        $payload = [
            'sub' => $user->getId(),
            'email' => $user->getEmail(),
            'iat' => time(),
            'exp' => time() + 3600
        ];
        return JWT::encode($payload, $this->jwtSecret, 'HS256');
    }
}
```

---

#### **3.3. Infrastructure Layer**
The Infrastructure layer handles external dependencies like databases and middleware.

##### **Repository Implementation: `MySqlUserRepository.php`**
```php
namespace App\Infrastructure\Repositories;

use App\Ports\UserRepository;
use App\Domain\User;
use PDO;

class MySqlUserRepository implements UserRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    public function save(User $user): void
    {
        $stmt = $this->pdo->prepare(
            "INSERT INTO users (id, name, email, password) VALUES (:id, :name, :email, :password)
             ON DUPLICATE KEY UPDATE name = :name, email = :email, password = :password"
        );
        $stmt->execute([
            'id' => $user->getId(),
            'name' => $user->getName(),
            'email' => $user->getEmail(),
            'password' => $user->getPassword(),
        ]);
    }

    public function findById(int $id): ?User
    {
        $stmt = $this->pdo->prepare("SELECT * FROM users WHERE id = :id");
        $stmt->execute(['id' => $id]);
        $data = $stmt->fetch(PDO::FETCH_ASSOC);
        return $data ? new User($data['id'], $data['name'], $data['email'], $data['password']) : null;
    }

    public function findByEmail(string $email): ?User
    {
        $stmt = $this->pdo->prepare("SELECT * FROM users WHERE email = :email");
        $stmt->execute(['email' => $email]);
        $data = $stmt->fetch(PDO::FETCH_ASSOC);
        return $data ? new User($data['id'], $data['name'], $data['email'], $data['password']) : null;
    }
}
```

---

### **4. MySQL Table Structure**

To store user data, we need to create a `users` table in the MySQL database. Below is the SQL script to create the table with proper UTF-8 support:

```sql
CREATE DATABASE my_hex_project CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE my_hex_project;

CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL
) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```

**Explanation:**
- `id`: A unique identifier for each user (auto-incremented).
- `name`: The user's full name.
- `email`: The user's email address (must be unique).
- `password`: The hashed password for authentication.
- `CHARACTER SET utf8mb4`: Ensures full Unicode support, including emojis.
- `COLLATE utf8mb4_unicode_ci`: Provides case-insensitive sorting and comparison.

---

### **5. Dependency Injection**

Dependency Injection (DI) is used to inject dependencies like repositories and services into controllers and other components.

##### **Example: `dependencies.php`**
```php
$builder->addDefinitions([
    UserRepository::class => \DI\autowire(MySqlUserRepository::class),
    AuthService::class => \DI\autowire()->constructorParameter('jwtSecret', 'your-secret-key'),
]);
```

---

### **6. Middleware**

Middleware is used to handle cross-cutting concerns like authentication and logging.

##### **Example: `AuthMiddleware.php`**
```php
public function __invoke(Request $request, callable $next): Response
{
    $authHeader = $request->getHeaderLine('Authorization');
    if (!$authHeader || !str_starts_with($authHeader, 'Bearer ')) {
        return $this->unauthorizedResponse();
    }

    $token = substr($authHeader, 7);
    try {
        $decoded = JWT::decode($token, new Key($this->jwtSecret, 'HS256'));
        $request = $request->withAttribute('user_id', $decoded->sub);
        return $next($request);
    } catch (\Exception $e) {
        return $this->unauthorizedResponse();
    }
}
```

---

### **7. Testing**

Write unit tests for your services and integration tests for your controllers. Use PHPUnit for testing:

```bash
vendor/bin/phpunit tests/
```

---

### **8. Running the Application**

Start the server:

```bash
php -S localhost:8000 -t public
```

Test the API endpoints:

- **Register a User:**
  ```bash
  curl -X POST http://localhost:8000/register \
  -H "Content-Type: application/json" \
  -d '{"name": "John Doe", "email": "john@example.com", "password": "secret"}'
  ```

- **Login:**
  ```bash
  curl -X POST http://localhost:8000/login \
  -H "Content-Type: application/json" \
  -d '{"email": "john@example.com", "password": "secret"}'
  ```

---

### **9. Conclusion**

By following this tutorial, youâ€™ve built a simple yet robust application using the Hexagonal Architecture. This approach ensures that your application is modular, testable, and maintainable. You can now extend it further by adding features like email notifications, logging, or integrating with external APIs.

If you have any questions, feel free to ask! ðŸ˜Š
